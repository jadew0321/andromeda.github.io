
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Alternative solutions to multi-variate control performance - Jade</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Less is More,摘要以最小方差控制为基准的多变量控制的性能评估需要已知交互矩阵来”过滤“闭环输出。这是将原始变量的坐标转换为新的坐标，以便从闭环输出马尔科夫参数的前几项识别控制不变扰动动力学。简化这种方法，特别是寻,"> 
    <meta name="author" content="Jade W"> 
    <link rel="alternative" href="atom.xml" title="Jade" type="application/atom+xml"> 
    <link rel="icon" href="/andromeda.github.io/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/andromeda.github.io/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">Jade</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://jadew0321.github.io/andromeda.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Alternative solutions to multi-variate control performance</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Alternative solutions to multi-variate control performance</h1>
        <div class="stuff">
            <span>十月 22, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/andromeda.github.io/tags/CPA/" rel="tag">CPA</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>以最小方差控制为基准的多变量控制的性能评估需要已知交互矩阵来”过滤“闭环输出。这是将原始变量的坐标转换为新的坐标，以便从闭环输出马尔科夫参数的前几项识别控制不变扰动动力学。简化这种方法，特别是寻找不需要交互器矩阵的方法，已经引起了人们极大的兴趣。基于这一动机，本文探讨了多变量控制性能评估问题的备选解决方案。特别地，我们将考虑两个实际的场景：</p>
<p>(1)已知每对输入和输出之间的时间延迟；</p>
<p>(2)没有关于过程模型或时间延迟的先验知识；</p>
<p>针对这两种情况提出了解决方案。基于子空间方法，推导了两种基于数据驱动的性能度量算法。并通过几个例子说明了所提方法的可行性。</p>
<h1 id="文章逻辑"><a href="#文章逻辑" class="headerlink" title="文章逻辑"></a>文章逻辑</h1><p><strong>背景：</strong>在过去的十年中，控制回路性能监测和诊断的研究一直是过程控制中最活跃的研究领域之一。在这个或相关方向估计已经发表了数百篇论文。在实际方面，Eastman Kodak最近报告定期循环监测超过14000 PID循环。尽管单变量控制监测的研究和应用取得了成功，但多变量控制性能评价的应用仍然是一个挑战。</p>
<p><strong>MVC及其缺陷：</strong>在控制性能监视的许多方法中，最小方差控制(MVC)基准仍然是最流行的基准。MVC基准在业内评估控制回路性能的适用性的原因之一是它是非侵入性的，常规的闭环运行数据是足以进行基准计算的。然而，这种方便只存在于单变量情况下，其中时间延迟是唯一需要的先验知识。对于多变量过程，这种简单性将丧失，因为时间延迟也不再是一个简单的技术概念。多变量过程需要一个交互矩阵，它的计算超出了每对输入和输出之间时延的知识。在这方面较早的工作是Huang等人和Harris等。这两种方法都需要相互作用矩阵的明确知识。</p>
<p><strong>针对该问题开展的工作：</strong>近年来，降低先验知识需求复杂性的研究兴趣日益浓厚，如Ko和Edgar ， Kadali和Huang ， McNabb和Qin提出的一些方法。尽管这些尝试在某种程度上降低了先验知识要求的复杂性，但它们都需要某些信息，这些信息在计算上比较简单，但在本质上等同于交互者矩阵，例如，开环过程马尔科夫参数矩阵，下三角Toeplitz矩阵，或多变量时滞(MTD)矩阵。也就是说，它们都需要一个先验知识，这个先验知识超出了每对输入和输出之间的纯时间延迟。Harris等人引入了一种不使用交互矩阵的 extended horizon 控制性能监控方法。Kadali和Huang，以及Shah等人引入了不依赖交互矩阵的多变量性能的曲率度量。最近，Huang等人提出了一种基于交互矩阵(OIM)阶数的多变量控制性能评估算法。</p>
<p><strong>提出本文思想基石：</strong>在单变量情况下，最小方差控制下的输出方差被解释为给定时滞过程的最优预测误差的方差。可以想象，如果闭环输出是高度可预测的，那么说明控制器应该能够做得更好，即通过一个设计良好的控制器来补偿可预测的内容。如果采用更好的控制器，那么闭环输出的可预测性就会降低。因此，闭环输出的高可预测性意味着通过控制重新调整和/或重新设计来提高其性能的潜力，或者换句话说，现有的控制器在探索其潜力方面可能不令人满意。</p>
<p>实际的过程往往有时间延迟，这阻止了对输出的可预测内容的完全补偿。例如，如果一个单变量过程有两个样本时滞，那么补偿控制动作要到两步后才会对输出产生影响，而一步超前预测对其补偿没有作用。在这种情况下，控制器能做的最好的就是根据两步最优预测(多步最优预测)对预测内容进行补偿，使最小控制误差与两步预测误差相等。因此，两步最优预测误差就是反馈控制器所能达到的输出误差的下界。这个下界也被称为最小方差，常用于控制环性能评估。</p>
<p>由于多变量过程的延迟结构相对复杂，虽然相同的原理不能准确地应用到多变量过程中，但多步最优预测提供了有关控制性能的有用信息。多步最优预测误差类似于单变量过程从白噪声到输出的闭环阶跃响应。这个类比为多变量过程的多步最优预测误差提供了一个有趣的解释，并为性能评估提供了一种新的措施。</p>
<p>虽然基于预测误差的方法可能是通用的，如果某些过程知识，如每一对输入和输出之间的时间延迟是可用的，那么结合该先验知识的控制性能评估方法会比基于预测误差的方法表现更好。</p>
<p>已知交互矩阵的对角形式只依赖于成对的时间延迟(每对输入和输出之间的延迟)。如果可以确定过程具有对角矩阵形式的交互矩阵，那么性能评估的计算就可以大大简化。因此，需要根据给定的成对时间延迟来确定一个进程是否具有对角交互矩阵。</p>
<p><strong>文章贡献：</strong>基于上述讨论，本文关注</p>
<p>(1)基于最优预测的替代性能评估方法的发展和分析；</p>
<p>(2)开发估计多步最优预测误差方差的两种数据驱动算法;</p>
<p>(3)确定过程是否具有交互矩阵的简单形式或对角形式的方法。</p>
<h1 id="交互矩阵"><a href="#交互矩阵" class="headerlink" title="交互矩阵"></a>交互矩阵</h1><p>考虑以下多变量过程：</p>
<script type="math/tex; mode=display">
Y_t=TU_t+Na_t</script><p>其中，$T$和$N$是以$q^{-1}$为滞后算子的传递函数矩阵；$Y_t,U_t,a_t$分别是输出、输入、和噪声向量。其中$a_t$假定为均值为零，方差为$\sum_a$的白噪声。$N$满足$N(q^{-1}=0)=I$，并且$N$是最小相位的，以实现扰动的添加。</p>
<ul>
<li><p>引理一</p>
<p>对于多项式传递函数矩阵$T$，维度为$n \times m$，存在不唯一的非奇异的多项式矩阵$D$，维度为$n \times n$，使得：</p>
<script type="math/tex; mode=display">
\lvert D \lvert=q^r\\
D^TD=I\\
\lim _{q^{-1} \rightarrow 0} D T=\lim _{q^{-1} \rightarrow 0} \widetilde{T}=K</script><p>其中，$K$是满秩的常数矩阵，整数$r$是$T$的infinite zero的个数，$\widetilde{T}$是$T$的delay-free传递函数矩阵，它只包含finite zero。矩阵$D$称为unitary交互矩阵，是传统下三角交互矩阵的等价形式，可以写成</p>
<script type="math/tex; mode=display">
D=D_0q^d+D_1q^{d-1}+…+D_{d-1}q</script><p>其中，$d$是交互矩阵的阶数，对于一个确定的传递函数矩阵来说是唯一的。$D_i$是系数矩阵。</p>
</li>
</ul>
<p>交互矩阵$D$可以是接下来描述的三种形式之一：</p>
<ol>
<li>如果$D=q^dI$，那么传递函数矩阵$T$可以看成是具有简单交互矩阵;</li>
<li>如果$D$是对角矩阵，即$D=diag(q^{d1},q^{d2},…，q^{dn})$，那么$T$可以看成是具有对角交互矩阵;</li>
<li>以上两种情形之外，$T$是通用交互矩阵。</li>
</ol>
<p>交互矩阵的计算需要一个完整的过程模型，或者至少是过程模型的前几个马尔科夫参数，这超出了对输入和输出之间的时间延迟的知识。对过程模型信息的这种需求一直是多变量控制性能评价技术应用的主要难点。</p>
<h1 id="方法——已知成对输入输出时延"><a href="#方法——已知成对输入输出时延" class="headerlink" title="方法——已知成对输入输出时延"></a>方法——已知成对输入输出时延</h1><p>在文献中已经表明，交互器滤波后的多变量闭环输出的移动平均展开式的前$d$项是反馈控制不变的，其中$d$是交互器矩阵的阶数:</p>
<script type="math/tex; mode=display">
\widetilde{Y}_{t}=q^{-d}DY_t
=\widetilde{F}_0a_t+\widetilde{F}_1a_{t-1}+…+\widetilde{F}_{d-1}a_{t-d}+\widetilde{F}_da_{t-d}+…</script><p>前$d$项表示实施了最小方差控制的闭环输出，最小方差指的就是$\widetilde{Y}_{t}$的协方差矩阵的迹最小。由于互矩阵的酉性质，$\widetilde{Y}_{t}$协方差的迹与${Y}_{t}$协方差的迹相同。如果已知交互矩阵，那么上述滑动平均展开式可以很轻易地计算得到，并且得到最小方差作为多变量控制性能评估的基准。</p>
<p>实际应用中的问题是，除对角交互矩阵外，对交互矩阵的计算需要过程模型的先验知识。特别是，为了计算互动矩阵，必须进行一项实验和识别工作。</p>
<p>与单变量控制性能评估不同，对于多变量控制性能评估，除了交互矩阵具有简单或对角结构的情形，其他情形下只知道两两时滞对于计算最小方差是不够的。</p>
<p>然而，如果每一对输入和输出的时延确实是已知的，我们应该寻找一个可能的简单或对角结构的交互矩阵，它可以直接导致计算多变量最小方差。简单的交互矩阵和对角交互矩阵都可以从过程的每对输入和输出之间的时间延迟中计算出来。人们可能会惊讶地发现，简单和对角交互矩阵并不少见，特别是在工业过程中，传递函数矩阵的稀疏结构经常被观察到。稀疏结构也有助于确定相互作用者的结构。</p>
<p>考虑一个$n \times m$的多变量传递函数矩阵：</p>
<p>图Snipaste_2020-10-22_14-27-55</p>
<p>其中，$T_{ij}$是标量传递函数，表示从第$j$个输入到第$i$个输出。定义如下的时延矩阵：</p>
<p>图Snipaste_2020-10-22_14-31-01</p>
<p>其中，$d_{ij}$是假设已知的时延，$t_{ij}$是从第$j$个输入到第$i$个输出的第一个非零脉冲响应系数，这是未知的。从上式，我们可以得到一个对角矩阵$\Theta$：</p>
<p>图Snipaste_2020-10-22_14-33-19</p>
<p>其中，$d_i=\min\left\{d_ij:j=1,…,m\right\}$</p>
<ul>
<li><p>引理二</p>
<p>如果$T$有对角交互矩阵$D$，那么$D=\Theta$</p>
</li>
<li><p>引理三</p>
<p>如果$K=\lim _{q^{-1} \rightarrow 0} \Theta \Psi$对于所有的$t_{ij} \ne 0$是满秩的，那么（1）交互矩阵是对角形式的；（2）交互矩阵$D=\Theta$。</p>
</li>
</ul>
<p>引理三给出了确定交互矩阵结构的一个充分条件。在实践中，我们可以通过检查$K$的行列式是否为零来松弛这个条件。步骤如下：(1) 计算行列式；(2)求出行列式为零的条件；(3)检查这些条件是否成立。</p>
<p>几个经典的多变量例子和一个工业例子可以来验证确定交互矩阵结构的方法。</p>
<h1 id="方法——未知任何先验知识"><a href="#方法——未知任何先验知识" class="headerlink" title="方法——未知任何先验知识"></a>方法——未知任何先验知识</h1><p>如果两两的时延是未知的或交互矩阵已被确定为非对角的，那么它是不可能估计最小方差从闭环例行操作数据。在这一节中，我们将考虑一种评估多变量控制回路性能的替代方法，而不依赖于任何相互作用矩阵的先验知识。文献中有几种无交互矩阵的方法，主要基于闭环脉冲响应和多步预测误差的方差。在本节中，我们将扩展上述方法，主要是基于方差预测误差的方法，以一种新的闭环潜能图形测量和单一数值测量控制性能潜能。</p>
<p>考虑一个闭环多变量过程，由下式滑动平均或Markov参数形式表示：</p>
<script type="math/tex; mode=display">
\widetilde{Y}_{t}=\widetilde{F}_0a_t+\widetilde{F}_1a_{t-1}+…+\widetilde{F}_{d-1}a_{t-d}+\widetilde{F}_da_{t-d}+…</script><p>假设$\sum_a=I$。然而，如果$\sum_a \ne I$，可以通过归一化操作：$F_i \leftarrow{F_i \sum_a^{1/2}} $和$a_t \leftarrow{ \sum_a^{-1/2}a_t}$，使得$\sum_a=I$。</p>
<p>上述移动平均模型可以从常规的操作数据估计，而不需要任何关于交互者矩阵的先验知识。</p>
<p>由于$a_t$是白噪声，那么$i$步最优预测可以通过下式得到：</p>
<script type="math/tex; mode=display">
Y_{t \mid t-i}=F_{i} a_{t-i}+F_{i+1} a_{t-i-1}+\cdots</script><p>预测误差$e_{t \mid t-i}=Y_{t}-Y_{t \mid t-i}$可通过下式计算：</p>
<script type="math/tex; mode=display">
e_{t \mid t-i}=F_{0} a_{t}+F_{1} a_{t-1}+\cdots+F_{i-1} a_{t-(i-1)}</script><p>预测误差的方差可通过下式计算：</p>
<script type="math/tex; mode=display">
\operatorname{Cov}\left(e_{t \mid t-i}\right)=F_{0} F_{0}^{\mathrm{T}}+F_{1} F_{1}^{\mathrm{T}}+\cdots+F_{i-1} F_{i-1}^{\mathrm{T}}</script><p>方差的迹可计算为：</p>
<script type="math/tex; mode=display">
s_{i} \triangleq \operatorname{tr}\left[\operatorname{Cov}\left(e_{t \mid t-i}\right)\right]=\operatorname{tr}\left(F_{0} F_{0}^{\mathrm{T}}+F_{1} F_{1}^{\mathrm{T}}+\cdots+F_{i-1} F_{i-1}^{\mathrm{T}}\right)</script><p>预测误差方差的增量可以计算为：</p>
<script type="math/tex; mode=display">
r_i\triangleq \operatorname{tr}\left[\operatorname{Cov}\left(e_{t \mid t-i}\right)-\operatorname{Cov}\left(e_{t \mid t-i}\right)\right]=\operatorname{tr} \left(F_{i-1} F_{i-1}^{\mathrm{T}}\right)</script><p>如果画出$s_i$关于$i$的曲线，可以看出该曲线反映了预测误差随着预测步长（prediction horizon，PH）增加而增加。注意，当$i\rightarrow{\infin}$，则$\operatorname{Cov}\left(e_{t \mid t-i}\right) \rightarrow \operatorname{Cov}\left(Y_t\right)$</p>
<p>注意：$s_i$是闭环响应对时间$i$的脉冲干扰的平方误差的和，如果我们画出$s_i$关于$i$的图，图中的每个点，代表了到时间$i$为止的闭环响应的平方误差和(SSE)。</p>
<p><strong>如果，在时间$i$之后，扰动可以被完全控制（例如通过无差拍控制），则响应的总误差仍为$s_i$，即$i$步最优预测误差。（从随机的观点来看）这也是为什么$s_i$曲线能够收敛的原因，这和普通的自回归预测不同。</strong></p>
<p><strong>由于$si$是平方闭环脉冲响应的总和，它类似于阶跃响应，可用于确定动态信息，如闭环响应对扰动的稳定时间。</strong></p>
<p>正如文献中所解释的，$r_i$是脉冲响应系数的2范数度量，类似于单变量过程的脉冲响应系数的平方。因此，$r_i$关于$i$的图，也可作为多变量控制器的闭环性能的指示，它已被用于一些商业软件的多变量控制性能监测。脉冲响应作为控制性能的一种测量方法的思想已经扩展到每个输出对每个扰动冲击的单个脉冲响应，以测量变量的相互作用。他们还建议使用预测误差方差分解(FEVD)来衡量交互作用。$si$是预测误差方差的总体度量，FEVD是单个变量对扰动的各个冲击的预测误差方差的分解。</p>
<p>闭环潜能$p_i$定义为如下所示：</p>
<script type="math/tex; mode=display">
p_i\triangleq \frac{s_\infin -s_i}{s_\infin}</script><p>因为$si$随$i$单调递增，所以$p_i$单调递减。由于$s_0=\operatorname{tr} [\operatorname{Cov}(Y_t-Y_{t\mid t})]=0$，所以$p_0=1$。由于$p_i$从$i=0$，值为1开始单调递减直到0。与脉冲响应或预测误差的方差不同，$p_i$是无量纲的，便于控制性能的比较。</p>
<p><strong>$p_i$可以解释为：如果时间$i$可以应用无差拍控制动作，那么过程输出SSE可以减少$100·pi \%$。</strong></p>
<p>从随机的角度来看，如果$i$大于相互作用的阶数$d$，则多变量输出的方差有可能减少当前方差的$100·pi\ %$</p>
<p>由于实际交互矩阵的阶数可能未知，可能可以通过查看控制潜能的轨迹得到。控制潜能衰减到零的速度越快，表明改进控制的可能性越小。由于控制潜能的单调递减性质和控制潜能的起止值是固定的，所以控制潜能图下方的面积可以很好地反映控制潜能衰减的速率。因此，可以定义标量索引来监视闭环控制潜能的变化。该指标称为相对闭环控制潜能指数，可计算为：</p>
<script type="math/tex; mode=display">
\eta_p=\frac{\sum p_i^{(2)}}{\sum p_i ^{(1)}}-1</script><p>$\eta_p$的值表示闭环控制潜能的百分比变化，正号表示控制潜能增加，负号表示控制潜能减少。注意，控制潜能的增加意味着调优恶化，而控制潜能的降低意味着调优改进。闭环控制潜能是控制误差方差的一种拓展。它自然地跟各种基于预测误差方差的指标相关。然而，这种图形化的扩展，对控制潜能的标量化度量，可解释性，都对之前的方法做了增强。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/andromeda.github.io/js/plugin.js"></script>
<script src="/andromeda.github.io/js/typed.js"></script>
<script src="/andromeda.github.io/js/diaspora.js"></script>


<link rel="stylesheet" href="/andromeda.github.io/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/andromeda.github.io/photoswipe/default-skin/default-skin.css">


<script src="/andromeda.github.io/photoswipe/photoswipe.min.js"></script>
<script src="/andromeda.github.io/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
