
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Notes for Process Control Performance Assessment - Jade</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Less is More,前言目的识别控制性能差的控制回路，并且诊断出性能不佳的原因。

Typical objectives are to identify poorly performing loops and to d,"> 
    <meta name="author" content="Jade W"> 
    <link rel="alternative" href="atom.xml" title="Jade" type="application/atom+xml"> 
    <link rel="icon" href="/andromeda.github.io/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/andromeda.github.io/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">Jade</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://jadew0321.github.io/andromeda.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Notes for Process Control Performance Assessment</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Notes for Process Control Performance Assessment</h1>
        <div class="stuff">
            <span>七月 11, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/andromeda.github.io/tags/booknotes/" rel="tag">booknotes</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>识别控制性能差的控制回路，并且诊断出性能不佳的原因。</p>
<blockquote>
<p>Typical objectives are to identify poorly performing loops and to diagnose causes for this unacceptable performance. </p>
</blockquote>
<h1 id="一、控制系统的经济监察"><a href="#一、控制系统的经济监察" class="headerlink" title="一、控制系统的经济监察"></a>一、控制系统的经济监察</h1><p>Economic Auditing of Control Systems</p>
<h3 id="过程控制基准度量标准的正式框架"><a href="#过程控制基准度量标准的正式框架" class="headerlink" title="过程控制基准度量标准的正式框架"></a>过程控制基准度量标准的正式框架</h3><p>Formal Framework for Process Control Benchmarking Metrics</p>
<p>在复杂的控制系统中，例如在生物体或大型国际组织中，目标通常是分层部署的，较高层次的目标控制次要层次目标的设定。这种分层控制可以用0级以上的过程控制方案表示，如下图所示。</p>
<p><img src="https://github.com/jadew0321/andromeda.github.io/blob/master/2020/07/11/Notes-for-Process-Control-Performance-Assessment/Snipaste_2020-07-14_10-49-51.png?raw=true" alt="**Snipaste_2020-07-14_10-49-51**"></p>
<p>层次结构中较低层次的目标是为实现较高层次目标而采取的行动的结果。一般来说，在存在随机干扰的情况下，控制回路会降低回路输出的可变性，但不能消除所有的变化。在原回路之上增加一个控制回路可以消除误差的变化。因此，控制层次结构中所需的级别数量将取决于单个控制循环的监管能力。</p>
<p>另一方面，增加水平的数量会对整体监管能力产生负面影响，因为反馈和控制行动信号必须经过的层次级别越多，它们就越有可能受到噪音、腐败或延迟的影响。控制层次中的每台设备影响低于它层次结构的组件。控制方案中的层次结构层越多，层次结构顶端的设备性能下降导致进程性能大幅下降的可能性就越大。正因为如此，控制专业人员一直在寻求最大限度地提高第1层和第2层的管理能力，从而尽可能减少实现整个过程目标所需的必要层的数量。这可能解释了为什么控制性能评估和基准测试应用程序的开发和使用主要集中于此流程控制层次结构的1-2级。由于第1级到第4级的特征不同，每个级别管理基准测试和性能考虑的一些因素也不同。为了合理地应用基准，并有效地利用基准的结果来改进过程和产品，需要了解在控制层次结构的每个层次所需要的基准和绩效评估标准的不同属性，以及这些标准之间的相互关系。</p>
<p>从上图可以看出，过程控制可以划分为过程单元全局协调的顶层、复杂过程单元在全局工艺线内无缝运行的单元级和单元内调节器自主运行的子单元级。整个过程控制本身可以表示为组织业务过程各层中的各个层次的组合。</p>
<p>下表显示了在业务流程的不同层对基准测试需求进行分类的框架。在流程和信息层面，基准和优化流程由本地性能指标的定义、技术优化标准、控制器设计和性能主导，较少受到操作员和/或团队工作小组的社会心理互动的影响。在经济层面上，基准和优化过程是由全球绩效指标、过程目标、业务运营策略和优化程序的定义主导的。性能指标有两种类型:</p>
<ul>
<li><p>产品性能度量: 这些是过程产品或输出的质量变量。</p>
</li>
<li><p>过程性能度量: 当生产产品或输出时，指示过程是否按预期方式运行的那些变量。</p>
</li>
</ul>
<p>性能指标的关键特征应该是:</p>
<ul>
<li>性能度量应该在物理上和技术上对被评估的过程有意义：因此，度量可以捕获并度量所需物理属性的存在，或者度量过程的经济维度。</li>
<li>性能指标最好能够经过优化分析，以计算出完全可实现的优化性能：进一步说，在存在结构化设计和实现约束的情况下，应该计算可实现的优化性能。</li>
</ul>
<h4 id="基准的目标"><a href="#基准的目标" class="headerlink" title="基准的目标"></a>基准的目标</h4><ul>
<li>公司：从产品的生产和销售中持续产生健康和不断增长的利润。</li>
<li>工程：为实现公司目标，创造持续改进的技术环境，以有效生产所需产品。</li>
<li>控制系统：通过确保安全和最佳的方法来提高/保持一致的生产率和产品质量，同时降低运营成本，工厂停机时间和维护成本，实现公司和工程的目标。</li>
</ul>
<h4 id="基准的原则"><a href="#基准的原则" class="headerlink" title="基准的原则"></a>基准的原则</h4><ul>
<li>在多变量流程中，流程循环之间存在交互作用，独立地优化每个循环并不能确保整个流程是最佳的。(“局部最优系统不一定转化为全局最优系统”)。</li>
<li>对流程中各个循环的性能进行基准测试，可以度量单个循环与局部最优值之间的距离，不足与说明流程的总体性能以及流程与全局最优值之间的距离。</li>
<li><p>流程的全局性能将主要由受约束回路的性能决定，这些回路受到一些物理、环境或用户强加的限制。</p>
</li>
<li><p>为了达到全局最优，对于被确定为过程目标关键的瓶颈环路，理想的工作点很可能是在约束条件下，所有其他环路的操作和性能都必须考虑这些限制。</p>
</li>
<li>为了实现全球过程范围的优化，控制目标必须来自管理和过程目标。</li>
</ul>
<h1 id="二、控制器基准——数据驱动方法"><a href="#二、控制器基准——数据驱动方法" class="headerlink" title="二、控制器基准——数据驱动方法"></a>二、控制器基准——数据驱动方法</h1><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>Benchmarking techniques are also important in other industrial sectors, such as the power generation and transmission industry. [Calligaris and Johnson, 1999, 2000]. 基准测试技术在其他工业部门（例如发电和输电行业）中也很重要。</p>
<h3 id="2、最小方差控制基准"><a href="#2、最小方差控制基准" class="headerlink" title="2、最小方差控制基准"></a>2、最小方差控制基准</h3><p>Minimum Variance Control Bechmarking</p>
<p>最小方差标准具有一定的基准价值，因为过程的经济绩效通常取决于设定点可以移近操作边界（例如温度极限）的程度。例如，操作边界代表原材料边界，那么方差的减少可能导致材料节省和收入增加。</p>
<p><img src="https://github.com/jadew0321/andromeda.github.io/blob/master/2020/07/11/Notes-for-Process-Control-Performance-Assessment/Snipaste_2020-08-06_09-18-27.png?raw=true" alt="**Snipaste_2020-08-06_09-18-27**"></p>
<h4 id="2-1-发展历程"><a href="#2-1-发展历程" class="headerlink" title="2.1 发展历程"></a>2.1 发展历程</h4><ol>
<li>最小方差准则（MVC）是一种由线性随机控制理论的应用简单实用的控制策略，最早是由[Åström，1967]提出的。 Åström使用MVC技术将输出信号的方差最小化，以控制造纸机中的纸张厚度。控制目标是在存在随机干扰的情况下，使纸张厚度的变化降至最低。从那时起，MVC技术吸引了许多实际应用[例如 Flunkert and Unbehauen，1993； Kaminskas et al。，1992]，获得了重要的理论发展，最终产生了模型预测控制技术</li>
<li>Harris and Desborough [1992]引入了归一化性能指标，用于对照最小方差控制基准评估控制器性能，该指标可以使用最小二乘法估算。基于Harris和Desborough方法的控制器性能指数（CPI）的实现包括对闭环的过程数据拟合自回归（AR）时间序列模型。</li>
</ol>
<h4 id="2-2-最小方差控制"><a href="#2-2-最小方差控制" class="headerlink" title="2.2 最小方差控制"></a>2.2 最小方差控制</h4><p>通用的随机反馈控制系统结构如下图所示：</p>
<p><img src="https://github.com/jadew0321/andromeda.github.io/blob/master/2020/07/11/Notes-for-Process-Control-Performance-Assessment/Snipaste_2020-08-10_14-57-26.png?raw=true" alt="Snipaste_2020-08-10_14-57-26"></p>
<p>MVC的基本假设是，回路是单输入单输出（SISO），线性，时不变的平稳随机过程，可以用下式表示：</p>
<script type="math/tex; mode=display">
A(z^{-1})y(t)=z^{-k}B(z^-1)u(t)+C(z^{-1})\xi(t)</script><p>其中$y(t)$表示输出信号围绕一个给定的稳态操作点的变化，$u(t)$表示控制信号，$\xi(t)$表示零均值，方差为$\sigma^2$的高斯白噪声扰动。$r(t)$表示设定值，是一个常数，为了方便起见可以设定为零。$A(z^{-1}),B(z^{-1}),C(z^{-1})$是以$z^{-1}$为向后移位算子的多项式。$B(z^{-1}),C(z^{-1})$的根假设在单位圆内。</p>
<script type="math/tex; mode=display">
\begin{array}{l}
A\left(z^{-1}\right)=1+a_{1} z^{-1}+a_{2} z^{-2}+\ldots+a_{n} z^{-n_{A}} \\
B\left(z^{-1}\right)=b_{0}+b_{1} z^{-1}+b_{2} z^{-2}+\ldots+b_{n} z^{-n_{B}} \quad b_{0} \neq 0 \\
C\left(z^{-1}\right)=1+c_{1} z^{-1}+c_{2} z^{-2}+\ldots+c_{n} z^{-n_{c}} \\
z^{-1} \cdot x(t)=x(t-1)
\end{array}</script><p>因此，$z^{-k}$在回路模型中表示控制信号有$k$步的延迟，这意味着控制信号在$k$个时间增量后开始作用于系统。整个过程由一个线性反馈控制器$C_o(z^{-1})$控制：</p>
<script type="math/tex; mode=display">
u(t)=-C_oy(t)</script><p>注，因为设定值为零，所以控制误差就是$-y(t)$；为了方便省略了参数$z^{-1}$。</p>
<p>应用上述过程模型，可以得到在$t+k$时刻的输出如下：</p>
<script type="math/tex; mode=display">
y(t+k)=\frac{B}{A}u(t)+\frac{C}{A}\xi(t+k)</script><p>定义如下的丢番图方程可以将多项式$C$拆分成两部分，一部分是$\xi$的历史值相关的，另一部分是和$\xi$的将来值相关的:</p>
<script type="math/tex; mode=display">
C=AF+z^{-k}G</script><p>其中，$F$ 和 $G$ 是如下的多项式：</p>
<script type="math/tex; mode=display">
F(z^{-1})=1+\sum_{i=1}^{k-1}f_iz^{-i}, G(z^{-1})=g_0+\sum_{i=1}^{n_G}g_iz^{-i}</script><p>其中$n_G=\max(n_C-k,n_A-1)$，代入$y(t+k)=\frac{B}{A}u(t)+\frac{C}{A}\xi(t+k)$得：</p>
<script type="math/tex; mode=display">
AFy(t+k)=BFu(t)+CF\xi(t+k)\\ 
(C-z^{-k}G)y(t+k)=BFu(t)+CF\xi(t+k)\\
Cy(t+k)=BFu(t)+CF\xi(t+k)+z^{-k}Gy(t+k)\\
=BFu(t)+CF\xi(t+k)+Gy(t)
\\
y(t+k)=\frac{BF}{C}u(t)+\frac{G}{C}y(t)+F\xi(t+k)</script><p>注意，等号右边的前两项和最后一项不相关。</p>
<p>由此可产生$k$步的输出提前预测公式：</p>
<script type="math/tex; mode=display">
\hat y\left(t+k|t \right) =\frac{BF}{C}u(t)+\frac{G}{C}y(t)</script><p>最小方差控制的cost函数是：给定包含$t$时刻为止的所有信息，目标最小化输出在$t+k$时刻的方差：</p>
<script type="math/tex; mode=display">
J(t)=E \left[y(t+k)^2\right]</script><p>其中表示期望，并且假设选择的控制必须是一个关于时刻t可用信息的函数，可用信息包含：所有过去的控制信号、所有过去的输出和现在的输出：</p>
<script type="math/tex; mode=display">
Y(t)=\left[u(t-k-1)\quad u(t-k-2)\quad ...\quad y(t)\quad y(t-1)\quad...\quad\right]</script><p>因此，输出的方差可以由下式得：</p>
<script type="math/tex; mode=display">
\sigma^2_y=E\left[y^2(t+k)\right]=E\left[\left(\frac{BF}{C}u(t)+\frac{G}{C}y(t)\right)^2\right]+E\left[\left(\xi(t+k)\right)^2\right]</script><script type="math/tex; mode=display">
J_{min} = E\left[\left(F\xi(t+k)^2\right)\right] \quad \text{and} \quad J_0=E\left[\left(\frac{BF}{C}u(t)+\frac{G}{C}y(t)\right)^2\right]</script><script type="math/tex; mode=display">
J=\sigma_y^2=J_{min}+J_o</script><p>其中$J_{min}$是和控制无关的，而$J_0$是取决于过程控制律的。</p>
<p>为了实现输出的最小方差控制，令$\frac{BF}{C}u(t)+\frac{G}{C}y(t)=0$，则$u(t)=-\frac{G}{BF}y(t)$</p>
<p>把最小方差控制器代入$y(t+k)=\frac{B}{A}u(t)+\frac{C}{A}\xi(t+k)$，可以得到$y(t+k)=F\xi(t+k)$</p>
<p>最小方差控制可以看作是无差拍控制的随机等价，因为它把所有闭环极点都放在原点。它通过消除过程动态性实现，这也解释了为什么最小方差控制通常是对过程模型不匹配积极的和敏感的。此外，它还需要一个最小相位系统来保持稳定。</p>
<h4 id="2-3-最小方差基准"><a href="#2-3-最小方差基准" class="headerlink" title="2.3 最小方差基准"></a>2.3 最小方差基准</h4><p>在最小方差控制下的输出方差可以通过下式计算：</p>
<script type="math/tex; mode=display">
J_{min}=\sum_{i=0}^{k-1}f_i^2\sigma^2</script><p>但是大多数控制器都不满足最小方差控制，即$J_0$不为0。因此，在定义未来输出$y(t+k)$的表达式中，有一个额外的方差非零项：</p>
<script type="math/tex; mode=display">
y(t+k)=F\xi(t+k)+\hat{y}(t)</script><p>其中，$\hat{y}(t)$是由于非优控制器带来的一部分输出，是关于$t$在$[-\infty, t-k]$范围内的函数；而可以看成是$k$步提前预测的误差，是关于$t$在时间范围$[t-k+1, t]$内的函数。由于这两部分输出是不相关的，所以输出的方差可以根据下式计算：</p>
<script type="math/tex; mode=display">
\sigma^2_y=E\left[\left(y(t+k)\right)^2\right]+E\left[\left(\hat{y}(t)\right)^2\right]</script><p>记$E\left[\left(\hat{y}(t)\right)^2\right]=\sigma^2_{soc}$，则输出的方差可用下式表示：</p>
<script type="math/tex; mode=display">
\sigma^2_y=\sigma^2_{soc}+\sigma^2_{mvc}</script><p>下标soc表示suboptimal control，mvc表示minimum variance。</p>
<p>则一个统一通用的控制性能指标（CPI）可以定义为：</p>
<script type="math/tex; mode=display">
\eta(k)=\frac{\sigma^2_{mvc}}{\sigma^2_{mvc}+\sigma^2_{soc}}</script><p>它既是归一化的，也是有界的，值在0-1之间：当值为1时，说明当前是最小方差控制，当值为0时，说明性能最差。</p>
<h4 id="2-4-CPI估算方法"><a href="#2-4-CPI估算方法" class="headerlink" title="2.4 CPI估算方法"></a>2.4 CPI估算方法</h4><p>本节介绍了一种使用线性回归方法从常规闭环过程数据估算CPI指标的简单方法，该方法无需求解丢番图方程或执行多项式长除法。</p>
<script type="math/tex; mode=display">
y(t+k)=\frac{BF}{C}u(t)+\frac{G}{C}y(t)+F\xi(t+k)\\
u(t)=-C_0(z^{-1})y(t)</script><p>则反馈控制下的过程闭环输出可以表示成如下：</p>
<script type="math/tex; mode=display">
y(t)=F\xi(t+k)+z^{-k}\left(\frac{G-BFC_0}{C}\right)y(t)\\</script><p>由于闭环被假定是稳定的，所以在上式右边的第二个分量可近似为有限长度自回归模型：</p>
<script type="math/tex; mode=display">
y(t)=F\xi(t)+\alpha_1y(t-k)+\alpha_2y(t-k-1)+\cdots+\alpha_my(t-k-m+1)\\
y(t)=F\xi(t)+\sum^m_{i=1}\alpha_iy(t-k-i+1)</script><p>其中$m$是自回归模型的长度。上述关系可写成向量形式：</p>
<script type="math/tex; mode=display">
\mathbf{y}=\mathbf{X}\alpha+\mathbf{F}\xi\\
\mathbf{y}=\left[\begin{array}{c}
y_{n} \\
y_{n-1} \\
\vdots \\
y_{k+m}
\end{array}\right] \quad \mathbf{X}=\left[\begin{array}{cccc}
y_{n-k} & y_{n-k-1} & \cdots & y_{n-k-m+1} \\
y_{n-k-1} & y_{n-k-2} & \cdots & y_{n-k-m} \\
\vdots & \vdots & \ddots & \vdots \\
y_{m} & y_{m-1} & \cdots & y_{1}
\end{array}\right] \quad \alpha=\left[\begin{array}{c}
\alpha_{1} \\
\alpha_{2} \\
\vdots \\
\alpha_{m}
\end{array}\right]</script><p>其中$n$是输出序列的总体长度。</p>
<p>通过记录闭环输出数据使用线性回归来估计自回归系数${\alpha_i}$，最小二乘的估计结果为：</p>
<script type="math/tex; mode=display">
\hat{\alpha}=\left(\mathbf{X}^T\mathbf{X}\right)^{-1}\mathbf{X}^T\mathbf{y}</script><p>最小方差控制下的输出方差可以通过下式计算：<u>(为啥前面的系数是n-k-2m+1？我觉得是n-k-m+1)</u></p>
<script type="math/tex; mode=display">
\hat{\sigma}^2_{mvc}=\sum^{k-1}_{i=0}f^2_i\sigma^2=\frac{1}{n-k-2m+1}\left(\mathbf{y}-\mathbf{X}\alpha\right)^T\left(\mathbf{y}-\mathbf{X}\alpha\right)</script><p>而实际运行中输出的方差为：</p>
<script type="math/tex; mode=display">
\hat{\sigma}^2_y=\frac{1}{n-k-m+1}\mathbf{y}^T\mathbf{y}=\hat{\sigma}^2_{soc}+\hat{\sigma}^2_{mvc}</script><p>则通用的CPI指标可以由下式计算：</p>
<script type="math/tex; mode=display">
\hat{\eta}(k)=\frac{n-k-m+1}{n-k-2m+1}\cdot\frac{\left(\mathbf{y}-\mathbf{X}\alpha\right)^T\left(\mathbf{y}-\mathbf{X}\alpha\right)}{\mathbf{y}^T\mathbf{y}+(n-k-m+1)\bar{\mathbf{y}}^2}</script><p>上式使用的是均方误差而不是方差，从而会惩罚非零稳态误差。</p>
<ul>
<li><p>对于该指标的可靠性进行讨论：</p>
<ol>
<li><p>n的选择</p>
<p>n过小，则估计可能不太可靠，会受离群值影响，估计出来的随机分布可能不正常，因为该估计本身就假设了较大的n值。</p>
<p>因此首先得给出一个合理的n，然后再进行在线评估。</p>
<p>验证n是否合理时，如果在给定一个n的情况下，CPI指标的方差很大，那么它的分布就会在平均值附近显示出较大的偏差。在这种情况下，n应该增加，直到分布有一个比较合理的较低的偏差。</p>
<p>实际应用时，n首先应该足够大，即$n\gg m$以去除噪音影响，并且也不能太大，防止计算能力超载。</p>
</li>
<li><p>使用数据：用于控制回路基准测试的工厂数据必须是未经过滤和压缩的，也就是说，数据必须与回路控制器使用的反馈信息完全相同。</p>
</li>
</ol>
</li>
<li><p>根据以上推导，使用最小方差控制基准进行控制器性能评估的步骤可列举如下：</p>
<ol>
<li>收集工厂的开环或闭环输出数据。数据应该是原始的，即不压缩或过滤。</li>
<li>选择一个样本数据集，其中$n$至少大于500，最好大于1000，即能包含系统中一些代表性的干扰。</li>
<li>根据先验知识，利用开环实验或闭环估计技术来估计样本的时延。</li>
<li>选择自回归模型长度$m$进行参数估计，一般选择$m$在5-30​之间。但模型长度取决于采样时间，应该选择能使系统脉冲响应被充分捕捉的一个模型长度。</li>
<li>根构造向量$\mathbf{y}$和矩阵$\mathbf{X}$。</li>
<li>计算模型参数 $\alpha_i$。</li>
<li>计算CPI指标。</li>
</ol>
</li>
</ul>
<h4 id="2-5-实验"><a href="#2-5-实验" class="headerlink" title="2.5 实验"></a>2.5 实验</h4><p>考虑一个连续时间的一阶过程，它的时间常数$T = 2s$，过程时延 $\iota=2s$，其传递函数为：</p>
<script type="math/tex; mode=display">
G(s)=\frac{e^{-2s}}{2s+1}</script><p>该过程受随机干扰的影响，通过加入有色噪声的过程输出模型。只考虑调节性能，因此假设设定点为零。</p>
<p>该过程是由一个PI控制器控制的，其中比例增益$K=2$，积分增益和积分时间为 $K_i=0.25,T_i=4s$。在$t_0=1000s$时，比例增益减少为$K=1$。</p>
<p><img src="https://github.com/jadew0321/andromeda.github.io/blob/master/2020/07/11/Notes-for-Process-Control-Performance-Assessment/Snipaste_2020-08-10_14-56-23.png?raw=true" alt="Snipaste_2020-08-10_14-56-23"></p>
<p>在切换瞬间附近的过程输出结果如上图所示。在该图中还绘制了基于控制器改变前后采集的1000个样本计算的自相关函数，采样时间选择为$T_s=1 s$。离散时延为$k=1+\frac{\iota}{T_s}=3s$。</p>
<p>显然，对于初始控制器设置，在时延之外，过程输出还有显著的相关关系，这表明性能不佳。因为最小方差控制要求在时延$k=3$之外就不再有任何相关性了。在进行控制器参数调节之后，输出的自相关性显著降低了，说明性能有了显著提升。</p>
<p>用最小方差基准对该过程进行评价，设置$m=10$，能达到的最小方差为0.22，控制器调节前后计算得到的控制性能指标分别为0.31和0.81。</p>
<p>CPI指数为0.81表明控制性能非常好。这时通过重新调整控制器仍有可能实现一个小的改进，但是很难说我们是否已经实现了当前控制器所能实现的最好的改进。这是因为像PID这样的简单控制器通常无法实现最小方差控制，特别是在存在死区和当被控对象的阶数高于这个简单例子时。除此之外，实现最小方差控制可能会导致过度的控制作用和控制回路的鲁棒性较差。由于这些原因，提出了一些替代的基准来评估控制回路的性能。</p>
<h4 id="2-6-非零设定值情形"><a href="#2-6-非零设定值情形" class="headerlink" title="2.6 非零设定值情形"></a>2.6 非零设定值情形</h4><p>在目前的讨论中，我们假设基准数据来自于调节回路，其中控制目标是保持被控制变量在一个恒定的设定值，并拒绝任何干扰。因此在线性系统模型中，设定值被假定为0，所以仅仅只考虑偏离这个额定工作点的情况。</p>
<p>然而，在闭环数据收集过程中，设定值可能会偶尔发生变化。在这种情况下，控制误差可以用来代替输出。如果数据集包含大量这样的设定值变化的情况，那么它们将被有效地视为额外的干扰，CPI指标将反映一个综合的调节性能和跟踪性能。一般来说，重要的是要确保用于计算性能基准的数据包含作用在系统上的典型干扰的充分表示。</p>
<h3 id="3、广义最小方差控制基准"><a href="#3、广义最小方差控制基准" class="headerlink" title="3、广义最小方差控制基准"></a>3、广义最小方差控制基准</h3>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/andromeda.github.io/js/plugin.js"></script>
<script src="/andromeda.github.io/js/typed.js"></script>
<script src="/andromeda.github.io/js/diaspora.js"></script>


<link rel="stylesheet" href="/andromeda.github.io/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/andromeda.github.io/photoswipe/default-skin/default-skin.css">


<script src="/andromeda.github.io/photoswipe/photoswipe.min.js"></script>
<script src="/andromeda.github.io/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
